Описание скриптов в адд-оне
         ALexusB 22.04.05
         
Дерево каталогов

Program\BATTLE_INTERFACE\ - скрипты интерфейсов на суще и море + быстрые переходы,
Program\CANNON\ - инициация и методы пушек,
Program\CHARACTERS\ - инициация персонажей и модули управления ими + форты + генератор фантомов,
Program\CONTROLS\ - настройки клавиш
Program\DIALOGS\ - скрипты диалогов по городам и генераторы + квесты,
Program\Encounters\ события на карте
Program\INTERFACE\ - скрипты интерфейса,
Program\ISLANDS\ - инициация островов и городов (товары для контрабанды и тп)
Program\ITEMS\ - инициация предметов
Program\LandEncounters\ - наземные энкаутеры (офицеры, райдеры, девки)
Program\Loc_ai\ - все АИ на суше, включая боевки и абордаж
Program\LOCATIONS\ - инициация локаций и модуль управления загрузгой НПС в них,
Program\NATIONS\ - инициация и модули наций (отношения, матрицы отношений)
Program\QUESTS\ - обработчики квестовых событий и модули управления событиями
Program\SEA_AI\ - АИ на море (все, что с кораблями) + переход в каюту, трюм, палубу
Program\SHIP\ - инициация типов кораблей,
Program\STORE\ - модуль управления магазинами (цены, товары),
Program\Weather\ - инициация погоды и смена погоды
Program\WORLDMAP\ - глобальная карта (коорд на ней, загрузка, события)
Program\ - общий код, модуль начала игры

RESOURCE\ - все ресурсы игры,
RESOURCE\INI\INTERFACES\ - дизайны интерфейса (расположение кнопок, иконки и тд)

Чем редактировать?
Я пользую TotalCommander + SynPlus 2.6
Подсветка синтексиса С++, сравнение файлов, Shift+Tab сдвигает выделение на таб влево, TAB - в право.
Таб должен быть установлен ровно 4 пробела!!!
Весь код идет по ГОСТу и только по нему.

======================
Особенности типов ПКМ
======================
На равне с базовыми типами С++ в игре есть свои собственные
object  - древовидная текстовая структура произвольной структуры (необходимо помнить, что все значения - строки)
все в игре объекты (точнее структуры)
например, ГГ - это первый элемент массива объектов всех НПС

далее
ref  - ссылка на объект
aref - ссылка на атрибут объекта (или ссылки на объект)

примеры

object Items[ITEMS_QUANTITY];
ref itm;
aref  arItm;

makeref(itm,Items[n]);
itm.id = "patent_eng";
itm.type.arm = true;

makearef(arItm,itm.type);

if (sti(arItm.arm) == true)
{
...
}


=============
Как писать диалоги
============
для примера берем простейший файл-заглушку

Miner_dialog.c    - говорят шахтеры

Комментарии по ходу

void ProcessDialogEvent()  - название метода обработки прерывания "разговор"
{
	ref NPChar;  - сам говорун
	aref Link, NextDiag;  - ссылки на атрибуты

	DeleteAttribute(&Dialog,"Links");  - трем все варианты ответов с того раза

	makeref(NPChar,CharacterRef);   - альяс глобальной переменной в локальную
	makearef(Link, Dialog.Links);      - ссылка на атрибут (  NPChar.Dialog.Links)
	makearef(NextDiag, NPChar.Dialog);   - ссылка на атрибут (просто удобно в коде, на деле это все часть NPChar)

	ref PChar;
	PChar = GetMainCharacter();   - наш ГГ

	switch(Dialog.CurrentNode)    - текущая ветка диалога (можно задать заранее до начала разговора по квесту, по умолчанию для всех "First time")
	{
		case "First time":
			Dialog.defAni = "dialog_stay1";     - настройки анимации головы и звуков (остатки роскоши от к2, работает частично можно не писать вообще, просто не будет мимики у бошки)
			Dialog.defCam = "1";
			Dialog.defSnd = "dialogs\0\017";
			Dialog.defLinkAni = "dialog_1";
			Dialog.defLinkCam = "1";
			Dialog.defLinkSnd = "dialogs\woman\024";
			Dialog.ani = "dialog_stay2";
			Dialog.cam = "1";
			Dialog.snd = "voice\MIDI\MIDI001";

            switch (rand(1))
			{
				case 0:
		     		dialog.text = "Поменьше болтай и побольше работай, друг. Стражники следят за нами, ты же не хочешь получить лишний удар плетью?";
					link.l1 = "Ты прав, нужно беречь силы.";
					link.l1.go = "exit";
				break;

				case 1:
					dialog.text = "Эх... как давно я не видел Солнце!!!";   - что говорит НПС
					link.l1 = "Зато добываемое золото блестит не хуже?";    - вариант ответа ГГ
					link.l1.go = "exit";                                    - куда переходим далее
				break;
			}

			NextDiag.TempNode = "first time";    - след ветка, если отработает    link.l1.go = "exit";
		break;

		case "Exit":
			DialogExit();   - выход их диалога
			NextDiag.CurrentNode = NextDiag.TempNode;     - запомним след ветвь
		break;
	}
}

====
Инфа

Что есть if в игре и почему так
ПКМ не поддерживает И и ИЛИ в одном выражении
т.е. if (a && b && (d || c)) - вызовет ошибку компилятора
Причем это вообще не подреживается в любых bool значениях (while и переменных)
Что делать
Вариант 1
if (a && b)
	if(d || c)

Вариант 2
bool ok;
ok = (d) || (c);
if (a && b && ok)

ВАЖНО (для оптимизации):
В ПКМ есть оптимизатор выражений
Пример, if (a && b) - b не будет проверяться, если а - ложь
if (a || b) b не будет проверяться, если а - истина

Это особо важно, если b - есть функция bool fun(), в который немерянный расчет.
Не нужно его вызывать, если итак все ясно.
Любые отрубания кода "галками" должы идти проверкой галки, а потом методов

это относится к хитрым вычислениям вида
ok = a>1;
ok = fun() || ok;
Это обратный пример - в данном случае нам НУЖНО, чтоб fun() отработал всегда, тк там пересчет, результат которого не важен, но важен сам расчет.


////////////////////////////////////////////////
Описание скриптов в ПКМ
         ALexusB 01.09.03
         
"Весь мир театр, а люди в нем актеры"(С)

По ходу игры главный герой сталкивается  различными персонажами. Добавить в игру новых персонажей или изменить реакции существующих - наша задача.

Все НПС (актеры или статисты) хранятся  в Characters[]
Попадают они туда при инициализации игры различными путями:
(здесь и далее я буду приводить описание методов и переменных исходя из того, что Вы знаете где их искать, иначе используйте поиск по папке программ)

CreateCharacters() -  инициализация всего массива и главного героя
CreateOtherCharacters(); - все остальные служедные НПС (в ПКМ это лодка на берегу)

Они заполняются в файлах офицеры, другие, квестовые персонажи и во всех файлов островов (C:\gama\seadog2\PROGRAM\Characters\init)
При этом счетчик n увеличивается. Всего в игру заложена возможность инициализации 1000 персонажей (но это изменяемо)

	makeref(ch,Characters[n]);		//Даниэль
	ch.name 	= "Даниель"; - имя в игре
	ch.lastname = "Грин";   - фамилия
	ch.id		= "Danielle"; - ИД перса для обращения к нему в коде
	ch.nation	= ENGLAND; - нация (ни на что не влияет)
	ch.model	= "Danielle"; - модель, можно менять динамически
	ch.activity_begin = "0";
	ch.activity_end = "24";
	ch.sex = "woman";  - пол :) (для модели нужно задать тип анимации model.animation = "woman";)
	ch.luck = 4;
	GiveItem2Character(ch, "blade6"); - заполняем карман
	TakeNItems(ch,"potion1", Rand(4)+1);
	ch.equip.blade = "blade6"; - что в руках
	GiveItem2Character(ch, GUN_COMMON);
	ch.equip.gun = GUN_COMMON; - что в руках, вообще есть спец метод екипировки, в инициализации рудимент
	ch.location	= ""; - где болтается (можно менять по сюжету)
	ch.location.group = ""; к какой группе принадлежит локатор
	ch.location.locator = ""; локатор, где конкретно болтается в локации, если пусто, то нигде нет, ждет своего часа
	ch.Dialog.Filename = "Danielle_dialog.c"; диалог, который сработает при обращении к персу
	ch.greeting = "Gr_danielle"; - альяс для звуков (список файлов, из которых перс вякает при диалоге)
	ch.rank 	= 4; - ранг
	ch.reputation = "50"; - репутация
	ch.experience = CalculateExperienceFromRank(4)+ (CalculateExperienceFromRank(4)/10 + rand(4000)); - текущий опыт (для адона рудимент)
	ch.skill.Leadership = "2"; - скилы
	ch.skill.Fencing = "4";
	ch.skill.Sailing = "2";
	ch.skill.Accuracy = "3";
	ch.skill.Cannons = "2";
	ch.skill.Grappling = "1";
	ch.skill.Repair = "1";
	ch.skill.Defence = "1";
	ch.skill.Commerce = "1";
	ch.skill.Sneak = "1"; - это удача, а не скрытность как написано :)
	ch.money = "0"; - деньги в кармане(т.е считай, что предмет)
	ch.perks.list.LongRangeShoot = true; - перки
	ch.Ship.Name = "Vertigo"; - имя корабля (может не быть корабля вообще. Для того чтою отобразить корабль в игре нужно спец функции вызвать)
	ch.Ship.Type = SHIP_SCHOONER2_ENGLAND;
	ch.Ship.Cannons.Type = CANNON_TYPE_CANNON_LBS16;
	ch.ship.cargo.goods.bombs = 1000;  - задавать так товары ИЗВРАТ (методы есть), но в инициализации бывает - рудимент.
	ch.FaceId = 30; - морда лица при диалоге (перекрывается дальше и тут не на что не влияет и не соответствует правде) - рудимент

типа
switch (rCharacter.model)
		{
			case "black_corsair": 	rCharacter.FaceId = 0; break;
			case "bocman1":			rCharacter.FaceId = 1; break;
			case "bocman3":			rCharacter.FaceId = 2; break;
			case "bocman4":			rCharacter.FaceId = 3; break;

Зависит исключительно от модели
Внимание! Добавление новой модели требует добавление морды!!!
Динамическая смена модели морду не меняет

Продолжение следует…..

==============================
Итак, у нас в игре все актеры и статисты обозначены.. Это не значит, что герой их сразу увидит. Многие должны сами появляться, а не сидеть сиднями..
Да, кстати, чтоб НПС именно сидел (в таверне) используется специальный локатор, например
ch.location.group = "sit";
ch.location.locator = "sit1";

Система квестов в игре основана на событиях
Ch.quest.Story_LeavingOxbay.win_condition.l1 = "location"; - тип события (появится в локации)
Ch.quest.Story_LeavingOxbay.win_condition.l1.character = "Blaze"; (кто появляется)
Ch.quest.Story_LeavingOxbay.win_condition.l1.location = "Oxbay"; (где)
Ch.quest.Story_LeavingOxbay.win_condition = "Story_leavingOxbay"; (состояние квеста при совпадении)
Ch.quest.Story_LeavingOxbay.fail_condition = "Story_leavingOxbay"; (при не совпадении, но вопрос??? Не ясно когда оно сработает и что будет.. возможно не сработает вовсе)

Введем терминологию
Состояние квеста - СК

Итак, СК обрабатывается в диалогах и, главное, в quests_reaction.c  QuestComplete();
И другими файлами из папки квест.

Нужно учесть, что СК это строка и никаких ошибок при ошибке в ней не будет вовсе
(эта беда игры - не перечислимый тип и бич тестеров. Не удивительно, что игру тестили целый год :) Поэтому, нужно быть очень внимательным!!!!

Продолжение следует…..

================== 18.11.05 ============
Почему нужно начинать игру заново после каждой правки?

Ну, не каждой :) Но нужно! Почему же так?

Во всем виноваты массивы и глобальные переменные. Да они!
Они гады пишутся в сайв и после этого новые переменные и элементы массивов в этот сайв уже не лезут.
А что делает добропорядочная игра при просьбе ее сделать то, что она не умеет? Правильно! Она вылетает в винду. :)

Есть еще засада с непреинициализацией переменных и массивов. Например, меняем местами люггер и фрегат в описании кораблей.
В старом сайве этот массив будет помнить еще старые значения, что приведет, если не к вылетам, то дисбалансу точно.
Хотя это еще и можно обойти спец кнопкой "совместить старый сайв с новым кодом" (только ее еще нет и нужно делать, но проблема №1 все равно обессмысливает сей труд)

